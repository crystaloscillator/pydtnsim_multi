#!/usr/bin/env python3
#
# Perl-compatible (generally, useful) functions.
# Copyright (c) 2018, Hiroyuki Ohsaki.
# All rights reserved.
#
# $Id: perl.py,v 1.7 2018/10/15 13:30:33 ohsaki Exp $
#

import getopt
import re
import sys

def warn(astr):
    """Display warning message to the standard error output.  Message
specified by FMT and *ARGS are formatted as like printf(3) in the C standard
library."""
    print(astr, file=sys.stderr)

def die(astr):
    """Display message to the standard error output and terminate the program
execution.  Message specified by FMT and *ARGS are formatted as like printf(3)
in the C standard library."""
    raise SystemExit(astr)

class _Options:
    def set(self, name, val):
        setattr(self, name, val)

def getopts(spec):
    """Parse UNIX-style command line options.  Parsed options are returned as
    an object.  A value for option X is accessible trhough the object
    attribute X."""
    # initialize all options with None
    opt = _Options()
    for name in spec:
        if name != ':':
            opt.set(name, None)

    # call getopt in the standard library
    try:
        opts, args = getopt.getopt(sys.argv[1:], spec)
    except getopt.GetoptError as e:
        print(e)
        return None

    # save parsed options as object attributes
    for key, val in opts:
        name = key[1:]
        if getopt.short_has_arg(name, spec):
            opt.set(name, val)
        else:
            opt.set(name, True)

    # discard already parsed arguments
    sys.argv[1:] = args
    return opt

def main():
    warn('test of %s function', 'warning')
    opt = getopts('al:') or die(
        f'usage: {sys.argv[0]} [-a] [-l line] [file...]')
    print(f'opt_a = {opt.a}')
    print(f'opt_l = {opt.l}')
    print(f'args = {sys.argv[1:]}')

if __name__ == "__main__":
    main()
