#!/usr/bin/env python3
#
#
# Copyright (c) 2018, Hiroyuki Ohsaki.
# All rights reserved.
#
# $Id: parser.py,v 1.6 2018/05/25 08:00:11 ohsaki Exp ohsaki $
#

import math
import os.path
import re
import time

import cell

def str2number(v):
    # FIXME: shoud not check type
    if type(v) != str:
        return v
    elif v.startswith('0x'):
        return int(v, 16)
    elif re.match(r'[\d+-]+$', v):
        return int(v)
    elif re.match(r'[\d.eE+-]+$', v):
        return float(v)
    else:
        return v

def get_args(args, defaults):
    values = []
    for i in range(len(defaults)):
        try:
            v = str2number(args[i])
        except IndexError:
            v = defaults[i]
        values.append(v)
    return values

class Parser:
    def __init__(self, cell=None):
        self.lineno = 0
        self.cell = cell

    def help(self):
        return """\
alpha (name|regexp) alpha
animate name (goal_x goal_y|name[(+|-)dx(+|-)dy])
attach name parent_name dx dy
color (name|regexp) color
define name bitmap file [(x y|name[(+|-)dx(+|-)dy])]
define name box [-f color] [width height color (x y|name[(+|-)dx(+|-)dy])]
define name ellipse [-f color] [rx ry color] [(x y|name[(+|-)dx(+|-)dy])]
define name line [-ht] sx sy dx dy [width color]
define name link src_name dst_name [width color]
define name polygon [-f color] [-r degree] n r [color (x y|name[(+|-)dx(+|-)dy])]
define name spline x1 y1 x2 y2 x3 y3 [width color]
define name text [-lcr] string [size color (x y|name[(+|-)dx(+|-)dy])]
define name wire [-ht] sx sy dx dy [width color]
dump
display
fade (name|regexp)...
hide (name|regexp)...
kill (name|regexp)...
move (name|regexp) (x y|name[(+|-)dx(+|-)dy])
palette symbol r g b [alpha]
priority (name|regexp) level
resize (name|regexp) (x y|name[(+|-)dx(+|-)dy])
shift (name|regexp) dx dy
scale (name|regexp) ratio
sleep x
spring [-f filter] [-r degree] (name|regexp)... [x1 y1 x2 y2]
unhide (name|regexp)...
wait
"""

    def abort(self, msg, *args):
        cell.die("%d: %s\n%s\n", self.lineno, self.line, msg, *args)

    def validate_color(self, color):
        try:
            self.cell.monitor.rgba(color)
        except KeyError:
            self.abort("undefined color '%s'", color)
        return color

    def expand_numeric_position(self, x, y):
        if -1 <= x <= 1:
            x *= self.cell.width
        if -1 <= y <= 1:
            y *= self.cell.height
        return x, y

    def expand_position(self, arg1, arg2=None):
        """ARG1 and ARG2 can be either float or string."""
        # FIXME: shoud not check type
        if type(arg1) == str:
            # object name with offset?
            m = re.search(r'(\w+)([+-][\d.]+)([+-][\d.]+)', arg1)
            if m:
                name, dx, dy = m.group(1), m.group(2), m.group(3)
                dx, dy = self.expand_position(dx, dy)
                return (self.cell.object(name).x + dx,
                        self.cell.object(name).y + dy)

            # object name?
            if self.cell.object(arg1):
                return (self.cell.object(arg1).x, self.cell.object(arg1).y)

            # must be positions
            if not re.search(r'[\d.eE+-]+', arg1):
                self.abort("inlvaid positional parameter '%s'", arg1)
            if not re.search(r'[\d.eE+-]+', arg2):
                self.abort("inlvaid positional parameter '%s'", arg2)
            return self.expand_numeric_position(float(arg1), float(arg2))
        else:
            return self.expand_numeric_position(arg1, arg2)

    def expand_palette(self, args):
        if len(args) == 1:
            v = str2number(args[0])
            r = (v >> 24) & 0xff
            g = (v >> 16) & 0xff
            b = (v >> 8) & 0xff
            a = v & 0xff
            return r, g, b, a
        return [str2number(v) for v in args]

    def expand_name(self, name, allow_create=False, allow_nomatch=False):
        # magic name
        if name == '-':
            return [None]

        # reference to the last object
        if name == '--':
            return [self.last_name]

        # regular expression
        m = re.match(r'/(.*)/', name)
        if m:
            regexp = m.group(1)
            matches = [name for name in self.cell.all_object_names() \
                    if re.search(regexp, name)]
            if not matches:
                if not allow_nomatch:
                    self.abort("non-matching regexp '%s'", regexp)
            return matches

        # number
        if re.match(r'[+-]?[\d.]+', name):
            return [name]

        # existing object
        if self.cell.object(name):
            return [name]

        if allow_create:
            return [name]
        else:
            self.abort("invalid name '%s'", name)

    def expand_names(self, *names, allow_create=False, allow_nomatch=False):
        found = []
        for name in names:
            found.extend(
                self.expand_name(
                    name,
                    allow_create=allow_create,
                    allow_nomatch=allow_nomatch))
        return found

    def parse_options(self, template, args):
        opt_type = {}
        for spec in re.findall(r'\w:?', template):
            if ':' in spec:
                opt_type[spec[0]] = 'with_arg'
            else:
                opt_type[spec[0]] = 'switch'

        opts = {}
        while args:
            m = re.match(r'-(\w)(.*)', args[0])
            if not m:
                break
            char, rest = m.group(1), m.group(2)
            if opt_type[char] == 'with_arg':
                if len(rest) > 0:
                    args.pop(0)
                    opts[char] = rest
                else:
                    args.pop(0)
                    opts[char] = args.pop(0)
            elif opt_type[char] == 'switch':
                opts[char] = True
                if len(rest) > 0:
                    args[0] = '-' + rest
                else:
                    args.pop(0)
            else:
                self.abort("unrecognized option '%s'", char)
        return opts

    def define_bitmap(self, name, args):
        file, x, y = get_args(args, [None, 0.5, 0.5])
        if not os.path.exists(file) and os.path.exists('figure/' + file):
            file = 'figure/' + file
        x, y = self.expand_position(x, y)

        obj = cell.Object(
            type='bitmap',
            name=name,
            file=file,
            x=x,
            y=y,
        )
        self.cell.add(obj)
        return obj

    def define_box(self, name, args, opts=None):
        width, height, color, x, y = get_args(args,
                                              [10, 10, 'white', 0.5, 0.5])
        width, height = self.expand_position(width, height)
        self.validate_color(color)
        x, y = self.expand_position(x, y)

        obj = cell.Object(
            type='box',
            name=name,
            width=width,
            height=height,
            color=color,
            x=x,
            y=y,
            frame_color=opts.get('f', None),
        )
        self.cell.add(obj)
        return obj

    def define_ellipse(self, name, args, opts):
        rx, ry, color, x, y = get_args(args, [10, 10, 'white', 0.5, 0.5])
        rx, ry = self.expand_position(rx, ry)
        self.validate_color(color)
        x, y = self.expand_position(x, y)

        obj = cell.Object(
            type='ellipse',
            name=name,
            width=rx * 2,
            height=ry * 2,
            color=color,
            x=x,
            y=y,
            frame_color=opts.get('f', None),
        )
        self.cell.add(obj)
        return obj

    def define_link(self, name, args):
        src_name, dst_name, width, color = get_args(args,
                                                    [None, None, 1, 'white'])
        if not self.cell.object(src_name):
            self.abort("undefined object '%s'", src_name)
        if not self.cell.object(dst_name):
            self.abort("undefined object '%s'", dst_name)
        self.validate_color(color)

        obj = cell.Object(
            type='link',
            name=name,
            src=self.cell.object(src_name),
            dst=self.cell.object(dst_name),
            width=width,
            color=color,
            priority=-20,
        )
        self.cell.add(obj)
        return obj

    def _define_arrowhead(self, name, x, y, x2, y2, size, color):
        rotation = 90 + cell.rad2deg(math.atan2(y2 - y, x2 - x))
        obj = self.define_polygon(name, [3, size, color, x2, y2],
                                  {'r': rotation})
        # FIXME: arrow head shoulbe attached
        return obj

    def define_line(self, name, args, opts):
        x, y, x2, y2, width, color = get_args(
            args, [0.25, 0.25, 0.75, 0.75, 1, 'white'])
        x, y = self.expand_position(x, y)
        x2, y2 = self.expand_position(x2, y2)
        self.validate_color(color)

        obj = cell.Object(
            type='line',
            name=name,
            x=x,
            y=y,
            x2=x2,
            y2=y2,
            width=width,
            color=color,
            priority=-10,
        )
        self.cell.add(obj)

        if opts.get('h', None):
            # FIXME: head size must be configurable
            self._define_arrowhead(name + '_head', x, y, x2, y2, width * 2,
                                   color)
        if opts.get('t', None):
            # FIXME: head size must be configurable
            self._define_arrowhead(name + '_tail', x2, y2, x, y, width * 2,
                                   color)

        return obj

    def define_polygon(self, name, args, opts):
        n, r, color, x, y = get_args(args, [3, 10, 'white', 0.5, 0.5])
        self.validate_color(color)
        x, y = self.expand_position(x, y)

        obj = cell.Object(
            type='polygon',
            name=name,
            n=n,
            width=r * 2,
            height=r * 2,
            color=color,
            x=x,
            y=y,
            rotation=float(opts.get('r', 0)),
            frame_color=opts.get('f', None),
        )
        self.cell.add(obj)
        return obj

    def define_spline(self, name, args, opts):
        x, y, x2, y2, x3, y3, width, color = get_args(
            args, [0.25, 0.25, 0.5, 0.5, 0.75, 0.75, 1, 'white'])
        x, y = self.expand_position(x, y)
        x2, y2 = self.expand_position(x2, y2)
        x3, y3 = self.expand_position(x3, y3)
        self.validate_color(color)

        obj = cell.Object(
            type='spline',
            name=name,
            x=x,
            y=y,
            x2=x2,
            y2=y2,
            x3=x3,
            y3=y3,
            width=width,
            color=color,
            priority=-10,
        )
        self.cell.add(obj)

        if opts.get('h', None):
            # FIXME: head size must be configurable
            self._define_arrowhead(name + '_head', x2, y2, x3, y3, width * 2,
                                   color)
        if opts.get('t', None):
            # FIXME: head size must be configurable
            self._define_arrowhead(name + '_tail', x2, y2, x, y, width * 2,
                                   color)
        return obj

    def define_text(self, name, args, opts):
        text, size, color, x, y = get_args(args, ['', 16, 'white', 0.5, 0.5])
        text = re.sub(r'__', ' ', text)
        self.validate_color(color)
        x, y = self.expand_position(x, y)
        align = 'center'
        if opts.get('l', None):
            align = 'left'
        if opts.get('r', None):
            align = 'right'

        obj = cell.Object(
            type='text',
            name=name,
            text=text,
            align=align,
            size=size,
            x=x,
            y=y,
            color=color,
            priority=10,
        )
        self.cell.add(obj)
        return obj

    # FIXME: merge with define_line since these are almost identical
    # FIXME: automatically detect horizontal/vertical directions
    def define_wire(self, name, args, opts):
        x, y, x2, y2, width, color = get_args(
            args, [0.25, 0.25, 0.75, 0.75, 1, 'white'])
        x, y = self.expand_position(x, y)
        x2, y2 = self.expand_position(x2, y2)
        self.validate_color(color)

        obj = cell.Object(
            type='wire',
            name=name,
            x=x,
            y=y,
            x2=x2,
            y2=y2,
            width=width,
            color=color,
            priority=-10,
        )
        self.cell.add(obj)

        if opts.get('h', None):
            # FIXME: head size must be configurable
            # force arrowhead to have a right angle
            self._define_arrowhead(name + '_head', x, y2, x2, y2, width * 2,
                                   color)
        if opts.get('t', None):
            # FIXME: head size must be configurable
            # force arrowhead to have a right angle
            self._define_arrowhead(name + '_tail', x2, y, x, y, width * 2,
                                   color)
        return obj

    def _parse_line(self, line):
        line = re.sub(r'^#.*', '', line)
        line = re.sub(r'^\s+', '', line)
        if not line:
            return

        args = line.split()
        cmd = args.pop(0).lower()
        try:
            current_name = args[0]
        except IndexError:
            current_name = None
        if cmd.startswith('al'):  # alpha
            name, alpha = args
            for n in self.expand_name(name):
                self.cell.object(n).alpha(alpha)
        elif cmd.startswith('an'):  # animate
            name = args.pop(0)
            x, y = self.expand_position(*args)
            for n in self.expand_name(name):
                self.cell.animate(n, x, y)
        elif cmd.startswith('at'):  # attach
            name, parent, dx, dy = get_args(args, [None, None, 0., 0.])
            dx, dy = self.expand_position(dx, dy)
            for n in self.expand_name(name):
                self.cell.object(n).attach(self.cell.object(parent), dx, dy)
        elif cmd.startswith('c'):  # color
            name, color = args
            self.validate_color(color)
            for n in self.expand_name(name):
                self.cell.object(n).color = color
        elif cmd.startswith('de'):  # define
            name, atype, *args = args
            name = self.expand_name(name, allow_create=True)[0]
            atype = atype.lower()
            if atype.startswith('bi'):
                self.define_bitmap(name, args)
            elif atype.startswith('bo'):
                opts = self.parse_options('f:', args)
                self.define_box(name, args, opts)
            elif atype.startswith('e'):
                opts = self.parse_options('f:', args)
                self.define_ellipse(name, args, opts)
            elif atype.startswith('link'):
                self.define_link(name, args)
            elif atype.startswith('l'):
                opts = self.parse_options('ht', args)
                self.define_line(name, args, opts)
            elif atype.startswith('p'):
                opts = self.parse_options('r:f:', args)
                self.define_polygon(name, args, opts)
            elif atype.startswith('s'):
                opts = self.parse_options('ht', args)
                self.define_spline(name, args, opts)
            elif atype.startswith('t'):
                opts = self.parse_options('lcr', args)
                self.define_text(name, args, opts)
            elif atype.startswith('w'):
                opts = self.parse_options('ht', args)
                self.define_wire(name, args, opts)
            else:
                self.abort("unknown object type '%s' in define.", atype)

        elif cmd.startswith('du'):  # dump
            raise NotImplemented
        elif cmd.startswith('fa'):  # fade
            for n in self.expand_names(*args):
                self.cell.object(n).fade_out = True
        elif cmd.startswith('fi'):  # fixed
            for n in self.expand_names(*args):
                self.cell.object(n).fixed = True
        elif cmd.startswith('di'):  # display
            self.cell.display()
        elif cmd.startswith('h'):  # hide
            for n in self.expand_names(*args):
                self.cell.object(n).visible = 0
        elif cmd.startswith('k'):  # kill
            for n in self.expand_names(*args, allow_nomatch=1):
                self.cell.delete(n)
        elif cmd.startswith('m'):  # move
            name = args.pop(0)
            (x, y) = self.expand_position(*args)
            for n in self.expand_name(name):
                self.cell.object(n).move(x, y)
        elif cmd.startswith('pa'):  # palette
            color = args.pop(0)
            r, g, b, a = self.expand_palette(args)
            self.cell.monitor.define_palette(color, r, g, b, a)
        elif cmd.startswith('pr'):  # priority
            name, level = args
            for n in self.expand_name(name):
                self.cell.object(n).priority = float(level)
        elif cmd.startswith('r'):  # resize
            name = args.pop(0)
            w, h = self.expand_position(*args)
            for n in self.expand_name(name):
                self.cell.object(n).resize(w, h)
        elif cmd.startswith('sc'):  # scale
            name, ratio = args
            for n in self.expand_name(name):
                self.cell.object(n).scale = ratio
        elif cmd.startswith('sh'):  # shift
            name, dx, dy = args
            dx, dy = self.expand_position(dx, dy)
            for n in self.expand_name(name):
                self.cell.object(n).shift(dx, dy)
        elif cmd.startswith('sl'):  # sleep
            secs = args.pop(0)
            time.sleep(secs)
        elif cmd.startswith('sp'):  # spring
            opts = self.parse_options('f:r:', args)
            x1, y1 = self.cell.width * 0.05, self.cell.height * 0.05
            x2, y2 = self.cell.width * 0.95, self.cell.height * 0.95
            args = self.expand_names(*args)
            if len(args) > 4 and re.match(r'[+-]?[\d.]+',
                                          args[-3]) and re.match(
                                              r'[+-]?[\d.]+', args[-1]):
                x1, y1, x2, y2 = args[-4:]
                del args[-4:]
                x1, y1 = self.expand_position(x1, y1)
                x2, y2 = self.expand_position(x2, y2)
            self.cell.spring(x1, y1, x2, y2, args, opts)
        elif cmd.startswith('u'):  # unhide
            for n in self.expand_names(*args):
                self.cell.object(n).visible = True
        elif cmd.startswith('w'):  # wait
            self.cell.wait()
        else:
            self.abort("illegal command '%s'", cmd)

        if self.cell.object(current_name):
            self.last_name = current_name

    def parse_line(self, line):
        self.line = line
        self.lineno += 1
        for l in line.split(';'):
            self._parse_line(l)
